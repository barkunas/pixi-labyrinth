[{"E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\index.js":"1","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\App.js":"2","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\reportWebVitals.js":"3","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\Game.js":"4","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\User.js":"5","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\AnimatedSprite.js":"6","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\appConfig.js":"7","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\GameField.js":"8","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\Wall.js":"9","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\common\\levelGenerator.js":"10","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\StatusBar.js":"11","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\PUXI\\SpritePuxi.js":"12"},{"size":940,"mtime":1612713413798,"results":"13","hashOfConfig":"14"},{"size":528,"mtime":1611086446219,"results":"15","hashOfConfig":"14"},{"size":362,"mtime":499162500000,"results":"16","hashOfConfig":"14"},{"size":3639,"mtime":1612721504912,"results":"17","hashOfConfig":"14"},{"size":1787,"mtime":1611962740357,"results":"18","hashOfConfig":"14"},{"size":522,"mtime":1611962330685,"results":"19","hashOfConfig":"14"},{"size":566,"mtime":1612718589554,"results":"20","hashOfConfig":"14"},{"size":3683,"mtime":1612719296103,"results":"21","hashOfConfig":"14"},{"size":2477,"mtime":1612719595239,"results":"22","hashOfConfig":"14"},{"size":3594,"mtime":1612099269655,"results":"23","hashOfConfig":"14"},{"size":884,"mtime":1612731277656,"results":"24","hashOfConfig":"14"},{"size":441,"mtime":1612733709728,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"29"},"1do2e3",{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"29"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"29"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"29"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"29"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"29"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\index.js",["57"],"import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport {Stage} from 'react-pixi-fiber'\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport Game from './Game';\r\nimport { APP_HEIGHT, APP_WIDTH } from './appConfig';\r\nimport * as PIXI from 'pixi.js'\r\n\r\nwindow.PIXI = PIXI\r\n\r\n/* ReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n); */\r\nReactDOM.render(\r\n  <Stage /* interactive={true} pointerdown={() => { console.log('ee') }} */ options={{ backgroundColor: 0x43bb43, height: APP_HEIGHT, width: APP_WIDTH }}>\r\n    <Game/>\r\n  </Stage>,\r\n  document.getElementById('gameView')\r\n)\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n",["58","59"],"E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\App.js",[],"E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\reportWebVitals.js",[],"E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\Game.js",["60"],"import React, { Component } from 'react'\r\nimport { Container, Text } from 'react-pixi-fiber'\r\nimport { APP_HEIGHT, APP_WIDTH, _PATHCoinOff } from './appConfig'\r\nimport getNewLevelConfig from './common/levelGenerator'\r\nimport GameField from './components/GameField'\r\nimport StatusBar from './components/StatusBar'\r\nimport User from './components/User'\r\n\r\nexport class Game extends Component {\r\n    startLevel = 1\r\n    state = {\r\n        isMoveActive: false,\r\n        runDirection: 0,\r\n        userLevel: this.startLevel,\r\n        levelConfig: this.generateNewLevel(this.startLevel),\r\n        updateWalls: 0,\r\n        coinsBalance:0\r\n    }\r\n    mouseDownHandler = (e) => {\r\n        console.log(e.data.global)\r\n    }\r\n    nextUserLevel = () => {\r\n        this.setState({ levelConfig: this.generateNewLevel(this.state.userLevel + 1), userLevel: this.state.userLevel + 1 })\r\n    }\r\n    removeCoinFromeMaze = (x, y) => {\r\n        let newLevel = { ...this.state.levelConfig }\r\n        newLevel.maze[y][x] = _PATHCoinOff\r\n        this.setState({ levelConfig: newLevel, updateWalls: this.state.updateWalls + 1,coinsBalance: this.state.coinsBalance + 1 })\r\n    }\r\n    generateNewLevel(userLevel) {\r\n        let levelWidth = userLevel + 5;\r\n        let levelHeight = userLevel + 5\r\n        var levelobj = getNewLevelConfig(levelHeight, levelWidth)\r\n        console.log(levelobj)\r\n        return levelobj\r\n    }\r\n    pointerdownHandler = (e) => {\r\n        let realX = e.data.global.x\r\n        let realY = e.data.global.y\r\n        let centerPointX = APP_WIDTH / 2;\r\n        let centerPointY = APP_HEIGHT / 2\r\n        let relativeX = realX - centerPointX\r\n        let relativeY = (realY - centerPointY) * -1\r\n        let direction = Math.atan2(relativeX, relativeY)\r\n        //if (direction < 0) { direction += 360 }\r\n        this.setState({ runDirection: direction, isMoveActive: true })\r\n    }\r\n    pointerupHandler = () => {\r\n        this.setState({ isMoveActive: false })\r\n    }\r\n    pointerupoutsideHandler = () => {\r\n        this.setState({ isMoveActive: false })\r\n    }\r\n    pointermoveHandler = (e) => {\r\n        if (!this.state.isMoveActive) { return }\r\n        let realX = e.data.global.x\r\n        let realY = e.data.global.y\r\n        let centerPointX = APP_WIDTH / 2;\r\n        let centerPointY = APP_HEIGHT / 2\r\n        let relativeX = realX - centerPointX\r\n        let relativeY = (realY - centerPointY) * -1\r\n        let direction = Math.atan2(relativeX, relativeY)\r\n        this.setState({ runDirection: direction })\r\n    }\r\n    render() {\r\n        return (\r\n            <Container\r\n                containsPoint={() => true}\r\n                interactive={true}\r\n                pointerdown={this.pointerdownHandler}\r\n                pointerup={this.pointerupHandler}\r\n                pointerupoutside={this.pointerupoutsideHandler}\r\n                pointermove={this.pointermoveHandler}\r\n            >\r\n                <GameField\r\n                    updateWalls={this.state.updateWalls}\r\n                    removeCoinFromeMaze={this.removeCoinFromeMaze}\r\n                    currentUserLevel={this.state.userLevel}\r\n                    nextUserLevel={this.nextUserLevel}\r\n                    isMoveActive={this.state.isMoveActive}\r\n                    runDirection={this.state.runDirection}\r\n                    maze={this.state.levelConfig.maze}\r\n                    gameFiledPosition={this.state.levelConfig.START_USER_POSITION_PX} />\r\n                <User />\r\n                <StatusBar userLevel={this.state.userLevel} coinsBalance={this.state.coinsBalance}/>\r\n            </Container>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Game\r\n","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\User.js",["61","62","63"],"import React, { Component } from 'react'\r\nimport { Sprite, withApp, Container } from 'react-pixi-fiber';\r\nimport * as PIXI from \"pixi.js\";\r\nimport { APP_HEIGHT, APP_WIDTH } from '../appConfig';\r\nimport AnimatedSprite from './AnimatedSprite';\r\n\r\nconst USER_IMG = 'img/sprites.json'\r\nconst FIRST_IMG_TEXTURE = 'character_base_16x16_01.png'\r\n\r\n\r\nclass User extends Component {\r\n    state = {\r\n        loadImg: false\r\n    }\r\n    addUser = (ref) => {\r\n        console.log(ref)\r\n    }\r\n    componentDidMount() {\r\n        PIXI.Loader.shared.add([USER_IMG,\"img/user/anim.json\"]).load(() => {this.setState({ loadImg: true })}) \r\n        //PIXI.Loader.shared.add(\"img/user/useranim/appFlash_atlas_1.json\").load(setup);\r\n\r\n        function setup() {\r\n            let sheet = PIXI.Loader.shared.resources[\"img/user/anim.json\"].spritesheet;\r\n            let animatedSprite = new PIXI.AnimatedSprite(sheet.animations[\"sprite\"]);\r\n            console.log(animatedSprite)\r\n        }\r\n    }\r\n    render() {\r\n        //console.log(this.props.app)\r\n        if (!this.state.loadImg) { return null }\r\n        //console.log(this.props.app)\r\n        //var PIXI = this.props.app\r\n        //let sheet = PIXI.Loader.shared.resources[USER_IMG].spritesheet;\r\n        //let texture = sheet.textures[FIRST_IMG_TEXTURE]\r\n        \r\n        let sheet = PIXI.Loader.shared.resources[\"img/user/anim.json\"].spritesheet;\r\n        let position = {\r\n            x: APP_WIDTH / 2-30,\r\n            y: APP_HEIGHT / 2-50\r\n        }\r\n        return (\r\n            <Container>\r\n                {/* <Sprite ref={this.addUser} texture={texture} {...position} /> */}\r\n                {<AnimatedSprite texture={sheet.animations[\"sprite\"]} {...position}/>}\r\n            </Container>\r\n        )\r\n    }\r\n}\r\n\r\nexport default withApp(User)\r\n","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\AnimatedSprite.js",[],"E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\appConfig.js",[],"E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\GameField.js",["64"],"import React, { Component } from 'react'\r\nimport { Container, withApp } from 'react-pixi-fiber'\r\nimport { APP_HEIGHT, APP_WIDTH, SPEED, _FINISH } from '../appConfig'\r\nimport Wall from './Wall'\r\n\r\nclass GameField extends Component {\r\n    contX = 0\r\n    contY = 0\r\n    state = {\r\n        wallPositionX: 0,\r\n        wallPositionY: 0\r\n    }\r\n    componentDidMount() {\r\n        this.props.app.ticker.add(this.moveBackground)\r\n    }\r\n    componentWillUnmount() {\r\n        this.props.app.ticker.remove(this.moveBackground);\r\n    }\r\n    getWallsBounds = (ref) => {\r\n        let bounds = ref.getBounds()\r\n        ref.setTransform(0, APP_HEIGHT - bounds.height)\r\n    }\r\n    moveBackground = () => {\r\n        if (this.props.isMoveActive) {\r\n            let plusX = SPEED * Math.sin(this.props.runDirection);\r\n            let plusY = SPEED * Math.cos(this.props.runDirection)\r\n            let walls = []\r\n            this.props.app.stage.children[0].children[0].children[0].children[0].children.forEach(element => {\r\n                let children = element.children\r\n                walls = [...walls, ...children]\r\n            });\r\n            let collisionWithWall = checkCollision(walls, plusX, plusY)\r\n            if (collisionWithWall) {\r\n                switch (collisionWithWall.type) {\r\n                    case _FINISH:\r\n                        this.setState({ wallPositionX: 0, wallPositionY: 0 })\r\n                        this.props.nextUserLevel();\r\n                        break;\r\n                    case 'coin':\r\n                        console.log(collisionWithWall)\r\n                        this.props.removeCoinFromeMaze(collisionWithWall.xPosInArray, collisionWithWall.yPosInArray)\r\n                        break;\r\n                    default:\r\n                        if (!checkCollision(walls, 0, plusY)) {\r\n                            let x = this.state.wallPositionX;\r\n                            let y = this.state.wallPositionY + plusY;\r\n                            this.setState({ wallPositionX: x, wallPositionY: y })\r\n                        } else if (!checkCollision(walls, plusX, 0)) {\r\n                            let x = this.state.wallPositionX - plusX;\r\n                            let y = this.state.wallPositionY;\r\n                            this.setState({ wallPositionX: x, wallPositionY: y })\r\n                        }\r\n                        break;\r\n                }\r\n            } else {\r\n                let x = this.state.wallPositionX - plusX;\r\n                let y = this.state.wallPositionY + plusY;\r\n                this.setState({ wallPositionX: x, wallPositionY: y })\r\n            }\r\n        }\r\n    }\r\n    render() {\r\n        return (\r\n            <Container x={this.props.gameFiledPosition.x} y={this.props.gameFiledPosition.y}>\r\n                <Container\r\n                    x={this.state.wallPositionX}\r\n                    y={this.state.wallPositionY}>\r\n                    <Wall update={this.props.updateWalls} maze={this.props.maze} />\r\n                </Container>\r\n            </Container>\r\n        )\r\n    }\r\n}\r\n\r\nexport default withApp(GameField)\r\n\r\nfunction checkCollision(walls, plusX, PlusY) {\r\n    let result = walls.findIndex((wall, i) => {\r\n        let bounds = wall.getBounds();\r\n        let user = { x: APP_WIDTH / 2 - 15, y: APP_HEIGHT / 2 + 15, width: 30, height: 30 };\r\n        let collision = bounds.x - plusX + bounds.width > user.x &&\r\n            bounds.x - plusX < user.x + user.width &&\r\n            bounds.y + PlusY + bounds.height - 10 > user.y &&\r\n            bounds.y + PlusY < user.y + user.height;\r\n        if (wall.type == 3) { return false }\r\n        return collision\r\n    });\r\n    return walls[result]\r\n}","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\Wall.js",["65"],"import React, { Component, PureComponent } from 'react'\r\nimport { Container, Sprite } from 'react-pixi-fiber'\r\nimport * as PIXI from 'pixi.js'\r\nimport wallSprite from '../img/bgtile.png'\r\nimport finishSprite from '../img/finish.png'\r\nimport startSprite from '../img/start.png'\r\nimport coinSprite from '../img/coin.png'\r\nimport { BLOCK_WIDTH, BLOCK_HEIGHT, _PATH, _START, _WALL, _FINISH } from '../appConfig'\r\n\r\nconst wallPIXITexture = PIXI.Texture.from(wallSprite)\r\nconst finishPIXITexture = PIXI.Texture.from(finishSprite)\r\nconst startPIXITExture = PIXI.Texture.from(startSprite)\r\nconst coinPIXITexture = PIXI.Texture.from(coinSprite)\r\n\r\nclass Wall extends PureComponent {\r\n    static props = {\r\n        maze: [[1]]\r\n    }\r\n    render() {\r\n        console.log('walls render')\r\n        let wallsBlock = []\r\n        this.props.maze.forEach((wallsArrayX, y) => {\r\n            let wallsLine = []\r\n            wallsArrayX.forEach((wall, x) => {\r\n                let sprite\r\n                switch (wall) {\r\n                    case _WALL:\r\n                        sprite = <Sprite type={wall} key={'' + _WALL + x + y} name=\"spr_wall\" x={BLOCK_WIDTH * x} y={0} texture={wallPIXITexture} />\r\n                        wallsLine.push(sprite)\r\n                        break;\r\n                    case _START:\r\n                        sprite = <Sprite type={wall} key={'' + _START + x + y} name=\"spr_wall\" x={BLOCK_WIDTH * x} y={0} texture={startPIXITExture} />\r\n                        wallsLine.push(sprite)\r\n                        break;\r\n                    case _FINISH:\r\n                        sprite = <Sprite type={wall} key={'' + _FINISH + x + y} name=\"spr_wall\" x={BLOCK_WIDTH * x} y={0} texture={finishPIXITexture} />\r\n                        wallsLine.push(sprite)\r\n                        break;\r\n                    case _PATH:\r\n                        sprite = <Sprite type={'coin'} xPosInArray={x} yPosInArray={y} key={'' + x + y + _PATH} name='spr_coin' x={BLOCK_WIDTH * x+20} y={0+20} texture={coinPIXITexture} />\r\n                        wallsLine.push(sprite)\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            })\r\n            wallsBlock.push(<Container key={y} y={BLOCK_HEIGHT * y}>{wallsLine}</Container>)\r\n        });\r\n        return (\r\n            <Container name={'wallsContainer'}>\r\n                {wallsBlock}\r\n            </Container>\r\n\r\n        )\r\n    }\r\n}\r\n\r\nexport default Wall\r\n","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\common\\levelGenerator.js",["66","67"],"import { APP_HEIGHT, APP_WIDTH, BLOCK_WIDTH, BG_CELL_SIZE, _WALL, _PATH, _START, _FINISH } from \"../appConfig\";\r\n\r\nexport default function getNewLevelConfig(COLLUMS, ROWS) {\r\n  // 1. Start with a grid full of walls.\r\n\r\n  let _COLLUMS = COLLUMS;\r\n  let _ROWS = ROWS;\r\n\r\n  let maze = [];\r\n  for (let i = 0; i < _COLLUMS; i++) {\r\n    maze.push([]);\r\n    for (let j = 0; j < _ROWS; j++)\r\n      maze[i][j] = _WALL;\r\n  }\r\n\r\n  // 2. Pick a cell, mark it as part of the maze. \r\n\r\n  let cell = { x: Math.floor(Math.random() * _COLLUMS), y: Math.floor(Math.random() * _ROWS) };\r\n  maze[cell.x][cell.y] = _PATH;\r\n\r\n  // 2.1 Add the walls of the cell to the wall list.\r\n\r\n  let walls = [];\r\n  if (cell.x + 1 < _COLLUMS) walls.push({ x: cell.x + 1, y: cell.y });\r\n  if (cell.x - 1 >= 0) walls.push({ x: cell.x - 1, y: cell.y });\r\n  if (cell.y + 1 < _ROWS) walls.push({ x: cell.x, y: cell.y + 1 });\r\n  if (cell.y - 1 >= 0) walls.push({ x: cell.x, y: cell.y - 1 });\r\n\r\n  // 3. While there are walls in the list:\r\n\r\n  while (walls.length > 0) {\r\n\r\n    // 3.1 Pick a random wall from the list.\r\n\r\n    let wallIndex = Math.floor(Math.random() * walls.length);\r\n    let wall = walls[wallIndex];\r\n\r\n    // 3.2 If only one of the two cells that the wall divides is visited, then:\r\n\r\n    let uc = []; // uc will be short for 'unvisited cell'\r\n\r\n    if (wall.x + 1 < _COLLUMS && maze[wall.x + 1][wall.y] === _PATH) uc.push({ x: wall.x - 1, y: wall.y });\r\n    if (wall.x - 1 >= 0 && maze[wall.x - 1][wall.y] === _PATH) uc.push({ x: wall.x + 1, y: wall.y });\r\n    if (wall.y + 1 < _ROWS && maze[wall.x][wall.y + 1] === _PATH) uc.push({ x: wall.x, y: wall.y - 1 });\r\n    if (wall.y - 1 >= 0 && maze[wall.x][wall.y - 1] === _PATH) uc.push({ x: wall.x, y: wall.y + 1 });\r\n\r\n    if (uc.length === 1) {\r\n\r\n      // 3.2.1 Make the wall a passage and mark the unvisited cell as part of the maze.\r\n\r\n      maze[wall.x][wall.y] = _PATH;\r\n      if (uc[0].x >= 0 && uc[0].x < _COLLUMS && uc[0].y >= 0 && uc[0].y < _ROWS) {\r\n        maze[uc[0].x][uc[0].y] = _PATH;\r\n\r\n        // 3.2.2 Add the neighboring walls of the cell to the wall list.\r\n\r\n        if (uc[0].x + 1 < _COLLUMS && maze[uc[0].x + 1][uc[0].y] === _WALL) walls.push({ x: uc[0].x + 1, y: uc[0].y });\r\n        if (uc[0].x - 1 >= 0 && maze[uc[0].x - 1][uc[0].y] === _WALL) walls.push({ x: uc[0].x - 1, y: uc[0].y });\r\n        if (uc[0].y + 1 < _ROWS && maze[uc[0].x][uc[0].y + 1] === _WALL) walls.push({ x: uc[0].x, y: uc[0].y + 1 });\r\n        if (uc[0].y - 1 >= 0 && maze[uc[0].x][uc[0].y - 1] === _WALL) walls.push({ x: uc[0].x, y: uc[0].y - 1 });\r\n      }\r\n    }\r\n\r\n    // 3.3 Remove the wall from the list.\r\n\r\n    walls.splice(wallIndex, 1);\r\n  }\r\n  //maze[cell.x][cell.y] = _START;\r\n  maze.forEach((array, i) => {\r\n    array.unshift(1)\r\n    array.push(1)\r\n  })\r\n  maze.unshift((function () {\r\n    let arr = [];\r\n    maze[0].forEach(() => {\r\n      arr.push(1)\r\n    })\r\n    return arr\r\n  })())\r\n  maze.push((function () {\r\n    let arr = [];\r\n    maze[0].forEach(() => {\r\n      arr.push(1)\r\n    })\r\n    return arr\r\n  })())\r\n  maze[1][1] = _START\r\n  maze[maze.length-2][maze[0].length-2] = _FINISH;\r\n  const START_USER_POSITION = []\r\n  START_USER_POSITION[0] = maze.findIndex(array => { return (0 <= array.find(elem => elem == _START)) });\r\n  START_USER_POSITION[1] = maze[START_USER_POSITION[0]].findIndex(elem => elem == _START)\r\n  const START_USER_POSITION_PX = {\r\n    x: 0 - START_USER_POSITION[1] * BLOCK_WIDTH + APP_WIDTH / 2-40,\r\n    y: 0 - START_USER_POSITION[0] * BG_CELL_SIZE + APP_HEIGHT / 2\r\n  }\r\n\r\n  return {\r\n    maze,\r\n    START_USER_POSITION_PX\r\n  }\r\n}","E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\StatusBar.js",[],"E:\\new_svn\\myProject\\pixitest\\pixi-labyrinth\\src\\components\\PUXI\\SpritePuxi.js",[],{"ruleId":"68","severity":1,"message":"69","line":5,"column":8,"nodeType":"70","messageId":"71","endLine":5,"endColumn":11},{"ruleId":"72","replacedBy":"73"},{"ruleId":"74","replacedBy":"75"},{"ruleId":"68","severity":1,"message":"76","line":2,"column":21,"nodeType":"70","messageId":"71","endLine":2,"endColumn":25},{"ruleId":"68","severity":1,"message":"77","line":2,"column":10,"nodeType":"70","messageId":"71","endLine":2,"endColumn":16},{"ruleId":"68","severity":1,"message":"78","line":8,"column":7,"nodeType":"70","messageId":"71","endLine":8,"endColumn":24},{"ruleId":"68","severity":1,"message":"79","line":22,"column":18,"nodeType":"70","messageId":"71","endLine":22,"endColumn":23},{"ruleId":"80","severity":1,"message":"81","line":85,"column":23,"nodeType":"82","messageId":"83","endLine":85,"endColumn":25},{"ruleId":"68","severity":1,"message":"84","line":1,"column":17,"nodeType":"70","messageId":"71","endLine":1,"endColumn":26},{"ruleId":"80","severity":1,"message":"81","line":90,"column":91,"nodeType":"82","messageId":"83","endLine":90,"endColumn":93},{"ruleId":"80","severity":1,"message":"81","line":91,"column":80,"nodeType":"82","messageId":"83","endLine":91,"endColumn":82},"no-unused-vars","'App' is defined but never used.","Identifier","unusedVar","no-native-reassign",["85"],"no-negated-in-lhs",["86"],"'Text' is defined but never used.","'Sprite' is defined but never used.","'FIRST_IMG_TEXTURE' is assigned a value but never used.","'setup' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'Component' is defined but never used.","no-global-assign","no-unsafe-negation"]